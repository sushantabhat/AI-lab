# -*- coding: utf-8 -*-
"""KNN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXrjxQ_VKdf7XOqnRmAYk3WeIOQLF-RG
"""

import pandas as pd
import numpy as np

def euclidean_distance(p, q):
    return np.sqrt(np.sum((p - q) ** 2))

# Manhattan Distance (L1 Norm)
def manhattan_distance(p, q):
    return np.sum(np.abs(p - q))

# Minkowski Distance
def minkowski_distance(p, q, p_value):
    return np.sum(np.abs(p - q) ** p_value) ** (1 / p_value)

# Define two vectors
vector1 = np.array([1, 2, 3])
vector2 = np.array([4, 5, 6])
# Call the function
distance = euclidean_distance(vector1, vector2)

print("Euclidean distance between the two vectors:", distance)
import numpy as np
# Define the data
data = [
    [2.7810836, 2.550537003, 0],
    [1.465489372, 2.362125076, 0],
    [3.396561688, 4.400293529, 0],
    [1.38807019, 1.850220317, 0],
    [3.06407232, 3.005305973, 0],
    [7.627531214, 2.759262235, 1],
    [5.332441248, 2.088626775, 1],
    [6.922596716, 1.77106367, 1],
    [8.675418651, -0.242068655, 1],
    [7.673756466, 3.508563011, 1]
]
# Convert the data to a numpy array
data_np = np.array(data)

# Split the data into X and Y
X = data_np[:, :2]  # Select all rows and the first two columns
Y = data_np[:, 2]   # Select all rows and the third column

# Display the X and Y arrays to verify
print("X array:")
print(X)
print("\nY array:")
print(Y)

import matplotlib.pyplot as plt
# Plot the data
plt.figure(figsize=(10, 6))

# Separate the data points based on their labels
for label in np.unique(Y):
    plt.scatter(X[Y == label][:, 0], X[Y == label][:, 1], label=f'Class {int(label)}')

# Add labels and title
plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Scatter Plot of Data Points')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()
from collections import Counter
# kNN algorithm
def k_nearest_neighbors(X, Y, query_point, k):
    distances = []

    # Calculate distances from the query point to all other points
    for i, point in enumerate(X):
        distance = euclidean_distance(point, query_point)
        distances.append((distance, Y[i]))

    # Sort distances in ascending order
    distances.sort(key=lambda x: x[0])

    # Select the k nearest neighbors
    k_nearest = distances[:k]

    # Get the labels of the k nearest neighbors
    k_nearest_labels = [label for _, label in k_nearest]

    # Determine the most common label (majority vote)
    majority_vote = Counter(k_nearest_labels).most_common(1)

    return majority_vote[0][0]

# Define a query point
query_point = np.array([7.0, 3.0])

# Set the value of k
k = 3

# Predict the class for the query point
predicted_class = k_nearest_neighbors(X, Y, query_point, k)

print(f"The predicted class for the query point {query_point} is: {predicted_class}")

# Method to plot the data
def plot_data(X, Y, query_point=None):
    plt.figure(figsize=(10, 6))

    # Separate the data points based on their labels
    for label in np.unique(Y):
        plt.scatter(X[Y == label][:, 0], X[Y == label][:, 1], label=f'Class {int(label)}')

    # Plot the query point if provided
    if query_point is not None:
        plt.scatter(query_point[0], query_point[1], c='red', marker='x', s=100, label='Query Point')

    # Add labels and title
    plt.xlabel('X1')
    plt.ylabel('X2')
    plt.title('Scatter Plot of Data Points')
    plt.legend()
    plt.grid(True)

    # Show the plot
    plt.show()

# Define the dataset
X = np.array([
    [2.7810836, 2.550537003],
    [1.465489372, 2.362125076],
    [3.396561688, 4.400293529],
    [1.38807019, 1.850220317],
    [3.06407232, 3.005305973],
    [7.627531214, 2.759262235],
    [5.332441248, 2.088626775],
    [6.922596716, 1.77106367],
    [8.675418651, -0.242068655],
    [7.673756466, 3.508563011]
])

Y = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1])

# Define a query point
query_point = np.array([3.0, 3.0])

# Set the value of k
k = 3

# Predict the class for the query point
predicted_class = k_nearest_neighbors(X, Y, query_point, k)
print(f"The predicted class for the query point {query_point} is: {predicted_class}")

# Plot the data with the query point
plot_data(X, Y, query_point)

import os
import pandas as pd

# Change the working directory to the directory containing the CSV file
os.chdir('/path/to/your/file/')

# Specify the path to the CSV file (can be relative now)
file_path = 'column_2C_weka.csv'

# Read the CSV file into a DataFrame
data_2C = pd.read_csv(file_path)

# Display the first few rows of the DataFrame to verify the data is loaded correctly
print(data_2C.head())

data_2C.describe().transpose()